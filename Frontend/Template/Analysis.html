<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Data Analysis - ClickTrain</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.plot.ly/plotly-2.26.0.min.js"></script>
  <style>
    .hover-lift:hover {
      transform: translateY(-2px);
    }

    .animate-fade-in {
      animation: fadeIn 0.6s ease-in-out;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(20px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    #plotTypeSelect,
    #generatePlotBtn {
      transition: all 0.3s ease;
    }

    #correlationHeatmap {
      min-height: 600px;
    }
  </style>
</head>

<body class="bg-white text-gray-900">
  <div id="ml-header"></div>

  <!-- Main Content -->
  <main class="min-h-screen py-16">
    <div class="max-w-7xl mx-auto px-4 md:px-8">
      <div class="text-center mb-12">
        <h1 class="text-4xl font-bold mb-4">Data Analysis</h1>
        <p class="text-xl text-gray-600">Comprehensive exploratory data analysis</p>
      </div>

      <!-- Loading Indicator -->
      <div id="loadingIndicator" class="text-center py-8">
        <p class="text-indigo-600">Loading analysis data...</p>
      </div>

      <!-- Data Summary Cards -->
      <div id="summaryCards" class="grid md:grid-cols-4 gap-6 mb-12 hidden">
        <div class="bg-white rounded-xl p-6 border border-gray-200 hover-lift transition-all duration-300 shadow-sm">
          <div class="text-xs font-bold uppercase tracking-widest text-indigo-400 mb-2">Shape</div>
          <h3 class="text-lg font-semibold mb-2">Dataset Shape</h3>
          <p class="text-2xl font-bold text-indigo-600" id="shape">-</p>
          <p class="text-sm text-gray-500">rows x columns</p>
        </div>
        <div class="bg-white rounded-xl p-6 border border-gray-200 hover-lift transition-all duration-300 shadow-sm">
          <div class="text-xs font-bold uppercase tracking-widest text-indigo-400 mb-2">Numeric</div>
          <h3 class="text-lg font-semibold mb-2">Numeric Columns</h3>
          <p class="text-2xl font-bold text-indigo-600" id="numericCols">-</p>
          <p class="text-sm text-gray-500">continuous features</p>
        </div>
        <div class="bg-white rounded-xl p-6 border border-gray-200 hover-lift transition-all duration-300 shadow-sm">
          <div class="text-xs font-bold uppercase tracking-widest text-indigo-400 mb-2">Category</div>
          <h3 class="text-lg font-semibold mb-2">Categorical Columns</h3>
          <p class="text-2xl font-bold text-indigo-600" id="catCols">-</p>
          <p class="text-sm text-gray-500">discrete features</p>
        </div>
        <div class="bg-white rounded-xl p-6 border border-gray-200 hover-lift transition-all duration-300 shadow-sm">
          <div class="text-xs font-bold uppercase tracking-widest text-indigo-400 mb-2">Missing</div>
          <h3 class="text-lg font-semibold mb-2">Missing Values</h3>
          <p class="text-2xl font-bold text-indigo-600" id="missingVals">-</p>
          <p class="text-sm text-gray-500">total missing</p>
        </div>
      </div>

      <!-- Numerical Feature Analysis -->
      <div id="numericalSection" class="bg-white rounded-xl p-6 border border-gray-200 mb-12 shadow-sm hidden">
        <h2 class="text-2xl font-semibold mb-6 text-indigo-600">Numerical Feature Analysis</h2>
        <div class="overflow-x-auto">
          <table class="w-full text-sm border-collapse">
            <thead>
              <tr class="bg-indigo-50">
                <th class="border border-gray-300 px-4 py-3 text-left font-semibold">Column</th>
                <th class="border border-gray-300 px-4 py-3 text-center font-semibold">Mean</th>
                <th class="border border-gray-300 px-4 py-3 text-center font-semibold">Median</th>
                <th class="border border-gray-300 px-4 py-3 text-center font-semibold">Std</th>
                <th class="border border-gray-300 px-4 py-3 text-center font-semibold">Min</th>
                <th class="border border-gray-300 px-4 py-3 text-center font-semibold">Max</th>
                <th class="border border-gray-300 px-4 py-3 text-center font-semibold">Skewness</th>
                <th class="border border-gray-300 px-4 py-3 text-center font-semibold">Kurtosis</th>
              </tr>
            </thead>
            <tbody id="numericalTable" class="bg-white"></tbody>
          </table>
        </div>
      </div>

      <!-- Categorical Feature Analysis -->
      <div id="categoricalSection" class="bg-white rounded-xl p-6 border border-gray-200 mb-12 shadow-sm hidden">
        <h2 class="text-2xl font-semibold mb-6 text-indigo-600">Categorical Feature Analysis</h2>
        <div class="overflow-x-auto">
          <table class="w-full text-sm border-collapse">
            <thead>
              <tr class="bg-indigo-50">
                <th class="border border-gray-300 px-4 py-3 text-left font-semibold">Column</th>
                <th class="border border-gray-300 px-4 py-3 text-center font-semibold">Unique Values</th>
                <th class="border border-gray-300 px-4 py-3 text-center font-semibold">Top Category</th>
                <th class="border border-gray-300 px-4 py-3 text-center font-semibold">Top Freq (%)</th>
                <th class="border border-gray-300 px-4 py-3 text-center font-semibold">Low Freq (%)</th>
                <th class="border border-gray-300 px-4 py-3 text-center font-semibold">Missing</th>
                <th class="border border-gray-300 px-4 py-3 text-center font-semibold">Missing (%)</th>
                <th class="border border-gray-300 px-4 py-3 text-center font-semibold">Cardinality</th>
              </tr>
            </thead>
            <tbody id="categoricalTable" class="bg-white"></tbody>
          </table>
        </div>
      </div>

      <!-- Correlation Analysis -->
      <div id="correlationSection" class="bg-white rounded-xl p-6 border border-gray-200 mb-12 shadow-sm hidden">
        <h2 class="text-2xl font-semibold mb-6 text-indigo-600">Correlation Analysis</h2>
        <div id="correlationHeatmap" class="mb-8"></div>
        <div id="topCorrelations" class="mt-6">
          <h3 class="text-xl font-semibold mb-4 text-indigo-600">Top 5 Strongest Positive Correlations</h3>
          <div id="topCorrList" class="space-y-2"></div>
        </div>
      </div>

      <!-- Custom Visualization Builder -->
      <div id="customVizSection" class="bg-white rounded-xl p-6 border border-gray-200 mb-12 shadow-sm hidden">
        <h2 class="text-2xl font-semibold mb-6 text-indigo-600">Custom Visualization Builder</h2>

        <!-- Axis hint -->
        <div class="mb-4 p-3 bg-indigo-50 border border-indigo-100 rounded-lg text-sm text-indigo-700">
          <strong>How to use:</strong>
          X-Axis accepts numerical columns only.
          Y-Axis accepts any column (numerical or categorical).
          Color/Hue accepts categorical columns only and can be the same column as Y-Axis.
        </div>

        <div class="grid md:grid-cols-4 gap-4 mb-6">
          <div>
            <label class="block text-sm font-medium mb-1 text-gray-700">X-Axis (Numerical only)</label>
            <select id="xAxisSelect"
              class="w-full px-3 py-2 border border-gray-300 rounded-lg bg-white text-gray-900 focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500">
              <option value="">Select X-axis...</option>
            </select>
          </div>
          <div>
            <label class="block text-sm font-medium mb-1 text-gray-700">Y-Axis (Any column)</label>
            <select id="yAxisSelect"
              class="w-full px-3 py-2 border border-gray-300 rounded-lg bg-white text-gray-900 focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500">
              <option value="">Select Y-axis...</option>
            </select>
          </div>
          <div>
            <label class="block text-sm font-medium mb-1 text-gray-700">Color / Hue (Categorical, Optional)</label>
            <select id="hueSelect"
              class="w-full px-3 py-2 border border-gray-300 rounded-lg bg-white text-gray-900 focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500">
              <option value="">Select hue...</option>
            </select>
          </div>
          <div>
            <label class="block text-sm font-medium mb-1 text-gray-700">Plot Type</label>
            <select id="plotTypeSelect"
              class="w-full px-3 py-2 border border-gray-300 rounded-lg bg-white text-gray-900 focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500">
              <option value="">Select plot type...</option>
            </select>
          </div>
        </div>

        <div class="text-center mb-4">
          <button id="generatePlotBtn"
            class="px-8 py-3 bg-indigo-600 text-white rounded-xl hover:bg-indigo-700 transition-colors duration-300 disabled:bg-gray-400 disabled:cursor-not-allowed font-semibold"
            disabled>
            Generate Plot
          </button>
        </div>

        <div id="customPlotContainer" class="mt-6"></div>
      </div>

      <!-- Navigation -->
      <div class="flex justify-between flex-wrap gap-4">
        <a href="upload.html"
          class="px-6 py-3 bg-gray-700 text-white rounded-xl hover:bg-gray-600 transition-colors duration-300">
          Back to Upload
        </a>
        <a href="preprocessing.html" id="nextLink"
          class="px-6 py-3 bg-indigo-600 text-white rounded-xl hover:bg-indigo-700 transition-colors duration-300">
          Proceed to Preprocessing
        </a>
      </div>
    </div>
  </main>

  <!-- Scripts -->
  <script>
    let sessionId = null;
    let allColumns = [];
    let numericalColumns = [];
    let categoricalColumns = [];
    let correlationMatrix = null;

    // 20-colour palette for hue groups
    const HUE_COLORS = [
      '#6366f1', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6',
      '#ec4899', '#14b8a6', '#f97316', '#06b6d4', '#84cc16',
      '#a855f7', '#fb923c', '#22d3ee', '#bef264', '#f43f5e',
      '#0ea5e9', '#fbbf24', '#34d399', '#c084fc', '#60a5fa'
    ];

    // Initialize
    document.addEventListener('DOMContentLoaded', function () {
      const urlParams = new URLSearchParams(window.location.search);
      sessionId = urlParams.get('session_id') || localStorage.getItem('session_id');
      if (!sessionId) {
        alert('No session ID found. Please upload a dataset first.');
        window.location.href = 'upload.html';
        return;
      }
      loadAnalysisData();
    });

    async function loadAnalysisData() {
      try {
        const response = await fetch('http://127.0.0.1:8000/api/eda/' + sessionId);

        if (!response.ok) {
          const errorData = await response.json().catch(function () { return { detail: 'Unknown error' }; });
          if (response.status === 404) {
            alert('Session not found. Please upload your dataset again.\n\nError: ' + (errorData.detail || 'Session expired or not found'));
            window.location.href = 'upload.html';
            return;
          }
          throw new Error('HTTP ' + response.status + ': ' + (errorData.detail || 'Failed to load analysis data'));
        }

        const data = await response.json();

        if (data.statistics) {
          const stats = data.statistics;

          document.getElementById('shape').textContent = stats.shape[0] + ' x ' + stats.shape[1];
          numericalColumns = stats.numerical_columns || [];
          categoricalColumns = stats.categorical_columns || [];
          allColumns = stats.columns || [];

          document.getElementById('numericCols').textContent = numericalColumns.length;
          document.getElementById('catCols').textContent = categoricalColumns.length;
          document.getElementById('missingVals').textContent = Object.values(stats.missing_values || {}).reduce(function (a, b) { return a + b; }, 0);

          document.getElementById('loadingIndicator').classList.add('hidden');
          document.getElementById('summaryCards').classList.remove('hidden');

          if (stats.numerical_stats && stats.numerical_stats.length > 0) {
            renderNumericalTable(stats.numerical_stats);
            document.getElementById('numericalSection').classList.remove('hidden');
          }

          if (stats.categorical_stats && stats.categorical_stats.length > 0) {
            renderCategoricalTable(stats.categorical_stats);
            document.getElementById('categoricalSection').classList.remove('hidden');
          }

          if (stats.correlation_matrix) {
            correlationMatrix = stats.correlation_matrix;
            renderCorrelationHeatmap(stats.correlation_matrix, numericalColumns);
            if (stats.top_correlations) { renderTopCorrelations(stats.top_correlations); }
            document.getElementById('correlationSection').classList.remove('hidden');
          }

          setupCustomVizBuilder();
          document.getElementById('customVizSection').classList.remove('hidden');
          document.getElementById('nextLink').href = 'preprocessing.html?session_id=' + sessionId;

        } else {
          throw new Error('Invalid response format');
        }
      } catch (error) {
        console.error('Analysis error:', error);
        if (error.message.indexOf('Failed to fetch') !== -1 || error.message.indexOf('NetworkError') !== -1) {
          alert('Failed to connect to backend server. Please make sure:\n1. Backend server is running on port 8000\n2. CORS is enabled\n3. No firewall is blocking the connection');
        } else {
          alert('Failed to load Analysis data: ' + error.message + '\n\nPlease check if the backend server is running on port 8000.');
        }
      }
    }

    function renderNumericalTable(stats) {
      const tbody = document.getElementById('numericalTable');
      tbody.innerHTML = '';
      stats.forEach(function (stat) {
        const tr = document.createElement('tr');
        tr.className = 'hover:bg-indigo-50 transition-colors';
        tr.innerHTML =
          '<td class="border border-gray-300 px-4 py-2 font-medium">' + stat.column + '</td>' +
          '<td class="border border-gray-300 px-4 py-2 text-center">' + stat.mean.toFixed(4) + '</td>' +
          '<td class="border border-gray-300 px-4 py-2 text-center">' + stat.median.toFixed(4) + '</td>' +
          '<td class="border border-gray-300 px-4 py-2 text-center">' + stat.std.toFixed(4) + '</td>' +
          '<td class="border border-gray-300 px-4 py-2 text-center">' + stat.min.toFixed(4) + '</td>' +
          '<td class="border border-gray-300 px-4 py-2 text-center">' + stat.max.toFixed(4) + '</td>' +
          '<td class="border border-gray-300 px-4 py-2 text-center">' + stat.skewness.toFixed(4) + '</td>' +
          '<td class="border border-gray-300 px-4 py-2 text-center">' + stat.kurtosis.toFixed(4) + '</td>';
        tbody.appendChild(tr);
      });
    }

    function renderCategoricalTable(stats) {
      const tbody = document.getElementById('categoricalTable');
      tbody.innerHTML = '';
      stats.forEach(function (stat) {
        const tr = document.createElement('tr');
        tr.className = 'hover:bg-indigo-50 transition-colors';
        const cardinalityClass = stat.cardinality === 'low' ? 'text-green-600' : stat.cardinality === 'medium' ? 'text-yellow-600' : 'text-red-600';
        tr.innerHTML =
          '<td class="border border-gray-300 px-4 py-2 font-medium">' + stat.column + '</td>' +
          '<td class="border border-gray-300 px-4 py-2 text-center">' + stat.unique_values + '</td>' +
          '<td class="border border-gray-300 px-4 py-2 text-center">' + stat.top_category + '</td>' +
          '<td class="border border-gray-300 px-4 py-2 text-center">' + stat.top_frequency_pct.toFixed(2) + '%</td>' +
          '<td class="border border-gray-300 px-4 py-2 text-center">' + stat.low_frequency_pct.toFixed(2) + '%</td>' +
          '<td class="border border-gray-300 px-4 py-2 text-center">' + stat.missing_count + '</td>' +
          '<td class="border border-gray-300 px-4 py-2 text-center">' + stat.missing_pct.toFixed(2) + '%</td>' +
          '<td class="border border-gray-300 px-4 py-2 text-center ' + cardinalityClass + ' font-semibold">' + stat.cardinality + '</td>';
        tbody.appendChild(tr);
      });
    }

    function renderCorrelationHeatmap(corrMatrix, columns) {
      const values = columns.map(function (col) {
        return columns.map(function (col2) { return corrMatrix[col] ? (corrMatrix[col][col2] || 0) : 0; });
      });

      const numCols = columns.length;
      const cellSize = Math.max(30, Math.min(60, 800 / numCols));
      const heatmapHeight = Math.max(600, numCols * cellSize + 200);
      const heatmapWidth = Math.max(800, numCols * cellSize + 200);
      const fontSize = Math.max(8, Math.min(12, 400 / numCols));

      const plotData = [{
        z: values,
        x: columns,
        y: columns,
        type: 'heatmap',
        colorscale: [[0, '#3b82f6'], [0.5, '#ffffff'], [1, '#ef4444']],
        zmid: 0,
        text: values.map(function (row) { return row.map(function (v) { return v.toFixed(3); }); }),
        texttemplate: numCols <= 15 ? '%{text}' : '',
        textfont: { size: fontSize },
        hovertemplate: '%{x} vs %{y}<br>Correlation: %{z:.3f}<extra></extra>',
        showscale: true,
        colorbar: { len: 0.8, thickness: 15, x: 1.15, y: 0.5 }
      }];

      const layout = {
        title: { text: 'Correlation Heatmap', font: { size: 20, color: '#4f46e5' }, x: 0.5, xanchor: 'center' },
        xaxis: { title: '', side: 'bottom', tickangle: -45, tickfont: { size: Math.max(9, Math.min(12, 300 / numCols)) } },
        yaxis: { title: '', tickfont: { size: Math.max(9, Math.min(12, 300 / numCols)) } },
        margin: { l: Math.max(120, numCols * 8), r: 120, t: 80, b: Math.max(120, numCols * 8) },
        width: heatmapWidth,
        height: heatmapHeight,
        autosize: false
      };

      const config = {
        responsive: true,
        displayModeBar: true,
        displaylogo: false,
        modeBarButtonsToAdd: ['resetScale2d'],
        modeBarButtonsToRemove: ['lasso2d', 'select2d'],
        toImageButtonOptions: { format: 'png', filename: 'correlation_heatmap', height: heatmapHeight, width: heatmapWidth, scale: 1 }
      };

      Plotly.newPlot('correlationHeatmap', plotData, layout, config).then(function () {
        const modebar = document.querySelector('#correlationHeatmap .modebar');
        if (modebar) {
          modebar.style.position = 'absolute';
          modebar.style.top = '10px';
          modebar.style.right = '10px';
          modebar.style.left = 'auto';
          modebar.style.bottom = 'auto';
        }
      });
    }

    function renderTopCorrelations(topCorr) {
      const container = document.getElementById('topCorrList');
      container.innerHTML = '';
      topCorr.forEach(function (corr, idx) {
        const div = document.createElement('div');
        div.className = 'bg-indigo-50 rounded-lg p-4 border border-indigo-200';
        div.innerHTML =
          '<div class="flex items-center justify-between">' +
          '<span class="font-semibold text-indigo-900">' + (idx + 1) + '. ' + corr.column1 + ' and ' + corr.column2 + '</span>' +
          '<span class="text-lg font-bold text-indigo-600">' + corr.correlation.toFixed(4) + '</span>' +
          '</div>';
        container.appendChild(div);
      });
    }

    // =========================================================================
    //  CUSTOM VISUALIZATION BUILDER
    // =========================================================================
    function setupCustomVizBuilder() {
      const xSelect = document.getElementById('xAxisSelect');
      const ySelect = document.getElementById('yAxisSelect');
      const hueSelect = document.getElementById('hueSelect');
      const plotTypeSelect = document.getElementById('plotTypeSelect');
      const generateBtn = document.getElementById('generatePlotBtn');

      // X-axis: NUMERICAL only
      numericalColumns.forEach(function (col) { xSelect.add(new Option(col, col)); });
      if (numericalColumns.length === 0) {
        xSelect.disabled = true;
        xSelect.innerHTML = '<option value="">No numerical columns available</option>';
      }

      // Y-axis: ALL columns
      allColumns.forEach(function (col) { ySelect.add(new Option(col, col)); });

      // Hue: CATEGORICAL only
      if (categoricalColumns.length === 0) {
        hueSelect.disabled = true;
        hueSelect.innerHTML = '<option value="">No categorical columns available</option>';
      } else {
        categoricalColumns.forEach(function (col) { hueSelect.add(new Option(col, col)); });
      }

      // Smart plot-type logic based on selected columns and their types
      function getPlotOptions() {
        const xVal = xSelect.value;
        const yVal = ySelect.value;
        const hueVal = hueSelect.value;
        if (!xVal && !yVal && !hueVal) { return []; }

        const yIsNum = numericalColumns.indexOf(yVal) !== -1;
        const yIsCat = categoricalColumns.indexOf(yVal) !== -1;

        // Only X selected (always numeric)
        if (xVal && !yVal && !hueVal) {
          return [
            { label: 'Histogram', value: 'histogram' },
            { label: 'Box Plot', value: 'box_plot' },
            { label: 'Violin Plot', value: 'violin_plot' }
          ];
        }

        // Only Y selected
        if (!xVal && yVal && !hueVal) {
          if (yIsNum) {
            return [
              { label: 'Histogram', value: 'histogram' },
              { label: 'Box Plot', value: 'box_plot' },
              { label: 'Violin Plot', value: 'violin_plot' }
            ];
          }
          return [{ label: 'Count Plot (Bar)', value: 'count_plot' }];
        }

        // Y + Hue (no X)
        if (!xVal && yVal && hueVal) {
          if (yIsNum) {
            return [
              { label: 'Grouped Box Plot', value: 'grouped_box_plot' },
              { label: 'Grouped Violin Plot', value: 'grouped_violin_plot' },
              { label: 'Colored Histogram', value: 'colored_histogram' }
            ];
          }
          return [
            { label: 'Grouped Bar Chart', value: 'grouped_bar_chart' },
            { label: 'Stacked Bar Chart', value: 'stacked_bar_chart' }
          ];
        }

        // Hue only (edge case)
        if (!xVal && !yVal && hueVal) {
          return [{ label: 'Count Plot (Bar)', value: 'count_plot' }];
        }

        // X + Y (no hue)
        if (xVal && yVal && !hueVal) {
          if (yIsNum) {
            return [
              { label: 'Scatter Plot', value: 'scatter_plot' },
              { label: 'Line Plot', value: 'line_plot' },
              { label: 'Box Plot', value: 'box_plot' },
              { label: 'Violin Plot', value: 'violin_plot' }
            ];
          }
          // Y is categorical
          return [
            { label: 'Grouped Bar Chart', value: 'grouped_bar_chart' },
            { label: 'Box Plot by Group', value: 'box_plot' },
            { label: 'Violin by Group', value: 'violin_plot' }
          ];
        }

        // X + Y + Hue
        if (xVal && yVal && hueVal) {
          if (yIsNum) {
            return [
              { label: 'Colored Scatter Plot', value: 'colored_scatter_plot' },
              { label: 'Grouped Box Plot', value: 'grouped_box_plot' },
              { label: 'Grouped Violin Plot', value: 'grouped_violin_plot' }
            ];
          }
          return [
            { label: 'Grouped Bar Chart', value: 'grouped_bar_chart' },
            { label: 'Stacked Bar Chart', value: 'stacked_bar_chart' }
          ];
        }

        return [];
      }

      function refreshPlotTypes() {
        const saved = plotTypeSelect.value;
        plotTypeSelect.innerHTML = '<option value="">Select plot type...</option>';
        const opts = getPlotOptions();
        opts.forEach(function (o) { plotTypeSelect.add(new Option(o.label, o.value)); });
        if (saved && opts.filter(function (o) { return o.value === saved; }).length) {
          plotTypeSelect.value = saved;
        }
        refreshButtonState();
      }

      function refreshButtonState() {
        const xVal = xSelect.value;
        const yVal = ySelect.value;
        const hueVal = hueSelect.value;
        const ready = !!(xVal || yVal || hueVal) && !!plotTypeSelect.value;

        generateBtn.disabled = !ready;
        if (ready) {
          generateBtn.classList.remove('bg-gray-400', 'cursor-not-allowed');
          generateBtn.classList.add('bg-indigo-600', 'hover:bg-indigo-700');
        } else {
          generateBtn.classList.remove('bg-indigo-600', 'hover:bg-indigo-700');
          generateBtn.classList.add('bg-gray-400', 'cursor-not-allowed');
        }

        // Ring highlight on plot type when axes chosen but type not picked yet
        const needsType = !!(xVal || yVal || hueVal) && !plotTypeSelect.value && getPlotOptions().length > 0;
        if (needsType) {
          plotTypeSelect.classList.add('ring-2', 'ring-indigo-300');
        } else {
          plotTypeSelect.classList.remove('ring-2', 'ring-indigo-300');
        }
      }

      // X and Hue are mutually exclusive.
      // Y and Hue CAN share the same categorical column.
      function syncDropdownOptions() {
        const xVal = xSelect.value;
        const hueVal = hueSelect.value;

        Array.from(xSelect.options).forEach(function (opt) {
          opt.disabled = !!(opt.value && opt.value === hueVal);
        });
        Array.from(ySelect.options).forEach(function (opt) {
          opt.disabled = !!(opt.value && opt.value === xVal);
        });
        Array.from(hueSelect.options).forEach(function (opt) {
          // Hue cannot be X; CAN be same as Y
          opt.disabled = !!(opt.value && opt.value === xVal);
        });

        refreshPlotTypes();
      }

      xSelect.addEventListener('change', syncDropdownOptions);
      ySelect.addEventListener('change', syncDropdownOptions);
      hueSelect.addEventListener('change', syncDropdownOptions);
      plotTypeSelect.addEventListener('change', refreshButtonState);
      generateBtn.addEventListener('click', generateCustomPlot);
    }

    // =========================================================================
    //  PLOT GENERATOR
    // =========================================================================
    async function generateCustomPlot() {
      const xCol = document.getElementById('xAxisSelect').value || null;
      const yCol = document.getElementById('yAxisSelect').value || null;
      const hueCol = document.getElementById('hueSelect').value || null;
      const plotType = document.getElementById('plotTypeSelect').value;
      const container = document.getElementById('customPlotContainer');

      if ((!xCol && !yCol) || !plotType) { return; }

      // Show loading state
      container.innerHTML =
        '<div class="flex items-center justify-center h-48">' +
        '<div class="animate-spin rounded-full h-12 w-12 border-4 border-indigo-600 border-t-transparent"></div>' +
        '<span class="ml-4 text-indigo-600 font-medium">Generating plot...</span>' +
        '</div>';

      try {
        // Build API URL
        const apiX = xCol || yCol;
        let url = 'http://127.0.0.1:8000/api/eda/' + sessionId + '/plot-data?x_col=' + encodeURIComponent(apiX);
        if (xCol && yCol) { url += '&y_col=' + encodeURIComponent(yCol); }
        if (hueCol) { url += '&hue_col=' + encodeURIComponent(hueCol); }

        const resp = await fetch(url);
        if (!resp.ok) { throw new Error('HTTP ' + resp.status); }
        const raw = await resp.json();

        // Normalise API response
        const rawX = raw.x_data || raw.data || [];
        const rawY = raw.y_data || [];
        const rawHue = raw.hue_data || [];
        const len = rawX.length;

        // Build aligned clean arrays - CRITICAL: filter x, y, hue at the SAME index
        const dataX = [], dataY = [], dataHue = [];
        for (let i = 0; i < len; i++) {
          const xOk = rawX[i] !== null && rawX[i] !== undefined;
          const yOk = !xCol || !yCol || (rawY[i] !== null && rawY[i] !== undefined);
          const hOk = !hueCol || (rawHue[i] !== null && rawHue[i] !== undefined);
          if (xOk && yOk && hOk) {
            dataX.push(rawX[i]);
            if (xCol && yCol) { dataY.push(rawY[i]); }
            if (hueCol) { dataHue.push(rawHue[i]); }
          }
        }

        const uniqueHues = hueCol ? Array.from(new Set(dataHue)) : [];
        const yIsNum = numericalColumns.indexOf(yCol) !== -1;
        const yIsCat = categoricalColumns.indexOf(yCol) !== -1;

        // Build layout
        const plotTitle = buildPlotTitle(plotType, xCol, yCol, hueCol);
        const layout = {
          title: { text: plotTitle, font: { size: 18, color: '#4f46e5', family: 'sans-serif' }, x: 0.5, xanchor: 'center' },
          xaxis: { title: { text: xCol || yCol || '', font: { size: 13 } }, zeroline: false, gridcolor: '#f0f0f0' },
          yaxis: { title: { text: (yCol && xCol) ? yCol : '', font: { size: 13 } }, zeroline: false, gridcolor: '#f0f0f0' },
          margin: { l: 80, r: hueCol ? 180 : 40, t: 90, b: 90 },
          height: 540,
          paper_bgcolor: '#ffffff',
          plot_bgcolor: '#fafafa',
          font: { family: 'sans-serif', size: 12, color: '#374151' },
          legend: hueCol ? { title: { text: hueCol }, bgcolor: '#ffffff', bordercolor: '#e5e7eb', borderwidth: 1, x: 1.02, y: 1 } : {}
        };

        let plotData = [];

        switch (plotType) {

          case 'histogram': {
            const src = dataX;
            const colName = xCol || yCol;
            if (hueCol && uniqueHues.length) {
              uniqueHues.forEach(function (h, i) {
                const vals = src.filter(function (_, idx) { return dataHue[idx] === h; });
                plotData.push({
                  x: vals, type: 'histogram', name: String(h), opacity: 0.72,
                  marker: { color: HUE_COLORS[i % HUE_COLORS.length] }
                });
              });
              layout.barmode = 'overlay';
            } else {
              plotData = [{
                x: src, type: 'histogram',
                marker: { color: '#6366f1', opacity: 0.85 },
                hovertemplate: 'Value: %{x}<br>Count: %{y}<extra></extra>'
              }];
            }
            layout.xaxis.title.text = colName;
            layout.yaxis.title.text = 'Count';
            break;
          }

          case 'box_plot': {
            if (!xCol && yCol && !hueCol) {
              plotData = [{
                y: dataX, type: 'box', name: yCol,
                marker: { color: '#6366f1' }, boxmean: 'sd', jitter: 0.3, pointpos: -1.5,
                boxpoints: dataX.length < 500 ? 'outliers' : false
              }];
              layout.xaxis.title.text = '';
              layout.yaxis.title.text = yCol;
            } else if (xCol && !yCol) {
              plotData = [{
                y: dataX, type: 'box', name: xCol,
                marker: { color: '#6366f1' }, boxmean: 'sd'
              }];
              layout.xaxis.title.text = '';
              layout.yaxis.title.text = xCol;
            } else if (hueCol && uniqueHues.length) {
              uniqueHues.forEach(function (h, i) {
                const mask = [];
                dataHue.forEach(function (hv, idx) { if (hv === h) { mask.push(idx); } });
                const ys = mask.map(function (i) { return (xCol && yCol) ? dataY[i] : dataX[i]; });
                plotData.push({
                  y: ys, name: String(h), type: 'box',
                  marker: { color: HUE_COLORS[i % HUE_COLORS.length] },
                  boxmean: 'sd', jitter: 0.3, boxpoints: ys.length < 500 ? 'outliers' : false
                });
              });
              layout.boxmode = 'group';
              layout.yaxis.title.text = yCol || xCol || '';
            } else {
              const groups = {};
              for (let i = 0; i < dataX.length; i++) {
                const k = String(dataX[i]);
                if (!groups[k]) { groups[k] = []; }
                groups[k].push(dataY[i]);
              }
              Object.keys(groups).forEach(function (k, i) {
                plotData.push({
                  y: groups[k], name: k, type: 'box',
                  marker: { color: HUE_COLORS[i % HUE_COLORS.length] }, boxmean: 'sd'
                });
              });
              layout.xaxis.title.text = xCol;
              layout.yaxis.title.text = yCol;
            }
            break;
          }

          case 'violin_plot': {
            if (!xCol && yCol && !hueCol) {
              plotData = [{
                y: dataX, type: 'violin', name: yCol,
                marker: { color: '#6366f1' }, box: { visible: true }, meanline: { visible: true }
              }];
              layout.xaxis.title.text = '';
              layout.yaxis.title.text = yCol;
            } else if (xCol && !yCol) {
              plotData = [{
                y: dataX, type: 'violin', name: xCol,
                marker: { color: '#6366f1' }, box: { visible: true }, meanline: { visible: true }
              }];
              layout.xaxis.title.text = '';
              layout.yaxis.title.text = xCol;
            } else if (hueCol && uniqueHues.length) {
              uniqueHues.forEach(function (h, i) {
                const mask = [];
                dataHue.forEach(function (hv, idx) { if (hv === h) { mask.push(idx); } });
                const ys = mask.map(function (i) { return (xCol && yCol) ? dataY[i] : dataX[i]; });
                plotData.push({
                  y: ys, name: String(h), type: 'violin',
                  marker: { color: HUE_COLORS[i % HUE_COLORS.length] },
                  box: { visible: true }, meanline: { visible: true }
                });
              });
              layout.violinmode = 'group';
              layout.yaxis.title.text = yCol || xCol || '';
            } else {
              const groups = {};
              for (let i = 0; i < dataX.length; i++) {
                const k = String(dataX[i]);
                if (!groups[k]) { groups[k] = []; }
                groups[k].push(dataY[i]);
              }
              Object.keys(groups).forEach(function (k, i) {
                plotData.push({
                  y: groups[k], name: k, type: 'violin',
                  marker: { color: HUE_COLORS[i % HUE_COLORS.length] },
                  box: { visible: true }, meanline: { visible: true }
                });
              });
              layout.xaxis.title.text = xCol;
              layout.yaxis.title.text = yCol;
            }
            break;
          }

          case 'count_plot': {
            const src = (!xCol && yCol) ? dataX : (hueCol && !xCol && !yCol ? dataHue : dataX);
            const colName = (!xCol && yCol) ? yCol : (hueCol && !xCol && !yCol ? hueCol : xCol);
            if (hueCol && uniqueHues.length && src.length && (xCol || yCol)) {
              uniqueHues.forEach(function (h, i) {
                const vals = src.filter(function (_, idx) { return dataHue[idx] === h; });
                const counts = {};
                vals.forEach(function (v) { counts[v] = (counts[v] || 0) + 1; });
                const keys = Object.keys(counts);
                plotData.push({
                  x: keys, y: keys.map(function (k) { return counts[k]; }), type: 'bar',
                  name: String(h), marker: { color: HUE_COLORS[i % HUE_COLORS.length] }
                });
              });
              layout.barmode = 'group';
            } else {
              const counts = {};
              src.forEach(function (v) { counts[v] = (counts[v] || 0) + 1; });
              const sorted = Object.keys(counts).map(function (k) { return [k, counts[k]]; }).sort(function (a, b) { return b[1] - a[1]; });
              plotData = [{
                x: sorted.map(function (e) { return e[0]; }), y: sorted.map(function (e) { return e[1]; }), type: 'bar',
                marker: { color: sorted.map(function (_, i) { return HUE_COLORS[i % HUE_COLORS.length]; }) }
              }];
            }
            layout.xaxis.title.text = colName;
            layout.yaxis.title.text = 'Count';
            break;
          }

          case 'scatter_plot': {
            if (hueCol && uniqueHues.length) {
              uniqueHues.forEach(function (h, i) {
                const mask = [];
                dataHue.forEach(function (hv, idx) { if (hv === h) { mask.push(idx); } });
                plotData.push({
                  x: mask.map(function (i) { return dataX[i]; }),
                  y: mask.map(function (i) { return dataY[i]; }),
                  mode: 'markers', type: 'scatter', name: String(h),
                  marker: {
                    size: 7, color: HUE_COLORS[i % HUE_COLORS.length], opacity: 0.85,
                    line: { width: 0.5, color: '#ffffff' }
                  }
                });
              });
            } else {
              plotData = [{
                x: dataX, y: dataY, mode: 'markers', type: 'scatter',
                marker: { color: '#6366f1', size: 6, opacity: 0.75, line: { width: 0.4, color: '#ffffff' } },
                hovertemplate: (xCol || '') + ': %{x}<br>' + (yCol || '') + ': %{y}<extra></extra>'
              }];
            }
            break;
          }

          case 'line_plot': {
            if (hueCol && uniqueHues.length) {
              uniqueHues.forEach(function (h, i) {
                const mask = [];
                dataHue.forEach(function (hv, idx) { if (hv === h) { mask.push(idx); } });
                const pts = mask.map(function (i) { return { x: dataX[i], y: dataY[i] }; }).sort(function (a, b) { return a.x - b.x; });
                plotData.push({
                  x: pts.map(function (p) { return p.x; }), y: pts.map(function (p) { return p.y; }),
                  mode: 'lines+markers', type: 'scatter', name: String(h),
                  marker: { size: 5, color: HUE_COLORS[i % HUE_COLORS.length] },
                  line: { color: HUE_COLORS[i % HUE_COLORS.length], width: 2 }
                });
              });
            } else {
              const pts = dataX.map(function (x, i) { return { x: x, y: dataY[i] }; }).sort(function (a, b) { return a.x - b.x; });
              plotData = [{
                x: pts.map(function (p) { return p.x; }), y: pts.map(function (p) { return p.y; }),
                mode: 'lines+markers', type: 'scatter',
                marker: { color: '#6366f1', size: 5 }, line: { color: '#6366f1', width: 2 }
              }];
            }
            break;
          }

          case 'colored_scatter_plot': {
            uniqueHues.forEach(function (h, i) {
              const mask = [];
              dataHue.forEach(function (hv, idx) { if (hv === h) { mask.push(idx); } });
              plotData.push({
                x: mask.map(function (i) { return dataX[i]; }), y: mask.map(function (i) { return dataY[i]; }),
                mode: 'markers', type: 'scatter', name: String(h),
                marker: {
                  size: 8, color: HUE_COLORS[i % HUE_COLORS.length], opacity: 0.85,
                  line: { width: 0.5, color: '#ffffff' }
                }
              });
            });
            break;
          }

          case 'grouped_box_plot': {
            uniqueHues.forEach(function (h, i) {
              const mask = [];
              dataHue.forEach(function (hv, idx) { if (hv === h) { mask.push(idx); } });
              const ys = mask.map(function (i) { return (xCol && yCol) ? dataY[i] : dataX[i]; });
              plotData.push({
                y: ys, name: String(h), type: 'box',
                marker: { color: HUE_COLORS[i % HUE_COLORS.length] },
                boxmean: 'sd', jitter: 0.3, boxpoints: ys.length < 500 ? 'outliers' : false
              });
            });
            layout.boxmode = 'group';
            layout.yaxis.title.text = yCol || xCol || '';
            break;
          }

          case 'grouped_violin_plot': {
            uniqueHues.forEach(function (h, i) {
              const mask = [];
              dataHue.forEach(function (hv, idx) { if (hv === h) { mask.push(idx); } });
              const ys = mask.map(function (i) { return (xCol && yCol) ? dataY[i] : dataX[i]; });
              plotData.push({
                y: ys, name: String(h), type: 'violin',
                marker: { color: HUE_COLORS[i % HUE_COLORS.length] },
                box: { visible: true }, meanline: { visible: true }
              });
            });
            layout.violinmode = 'group';
            layout.yaxis.title.text = yCol || xCol || '';
            break;
          }

          case 'colored_histogram': {
            const src = (yCol && !xCol) ? dataX : (dataY.length ? dataY : dataX);
            const colName = (yCol && !xCol) ? yCol : (yCol || xCol);
            uniqueHues.forEach(function (h, i) {
              const vals = src.filter(function (_, idx) { return dataHue[idx] === h; });
              plotData.push({
                x: vals, type: 'histogram', name: String(h), opacity: 0.72,
                marker: { color: HUE_COLORS[i % HUE_COLORS.length] }
              });
            });
            layout.barmode = 'overlay';
            layout.xaxis.title.text = colName;
            layout.yaxis.title.text = 'Count';
            break;
          }

          case 'grouped_bar_chart': {
            if (yIsCat && hueCol && uniqueHues.length && dataY.length) {
              const cats = Array.from(new Set(dataY));
              uniqueHues.forEach(function (h, i) {
                const counts = {};
                cats.forEach(function (c) { counts[c] = 0; });
                dataY.forEach(function (v, idx) { if (dataHue[idx] === h) { counts[v] = (counts[v] || 0) + 1; } });
                plotData.push({
                  x: cats, y: cats.map(function (c) { return counts[c]; }), type: 'bar', name: String(h),
                  marker: { color: HUE_COLORS[i % HUE_COLORS.length] }
                });
              });
              layout.barmode = 'group';
              layout.xaxis.title.text = yCol;
              layout.yaxis.title.text = 'Count';
            } else if (xCol && yIsCat && !hueCol) {
              const cats = Array.from(new Set(dataY));
              const sums = {}, cnts = {};
              cats.forEach(function (c) { sums[c] = 0; cnts[c] = 0; });
              dataY.forEach(function (v, i) { sums[v] += dataX[i]; cnts[v]++; });
              plotData = [{
                x: cats, y: cats.map(function (c) { return cnts[c] ? sums[c] / cnts[c] : 0; }), type: 'bar',
                marker: { color: cats.map(function (_, i) { return HUE_COLORS[i % HUE_COLORS.length]; }) }
              }];
              layout.xaxis.title.text = yCol;
              layout.yaxis.title.text = 'Mean of ' + xCol;
            } else {
              const src = dataX;
              const counts = {};
              src.forEach(function (v) { counts[v] = (counts[v] || 0) + 1; });
              const sorted = Object.keys(counts).map(function (k) { return [k, counts[k]]; }).sort(function (a, b) { return b[1] - a[1]; });
              plotData = [{
                x: sorted.map(function (e) { return e[0]; }), y: sorted.map(function (e) { return e[1]; }), type: 'bar',
                marker: { color: sorted.map(function (_, i) { return HUE_COLORS[i % HUE_COLORS.length]; }) }
              }];
              layout.xaxis.title.text = xCol || yCol;
              layout.yaxis.title.text = 'Count';
            }
            break;
          }

          case 'stacked_bar_chart': {
            if (uniqueHues.length && dataY.length) {
              const cats = Array.from(new Set(dataY));
              uniqueHues.forEach(function (h, i) {
                const counts = {};
                cats.forEach(function (c) { counts[c] = 0; });
                dataY.forEach(function (v, idx) { if (dataHue[idx] === h) { counts[v] = (counts[v] || 0) + 1; } });
                plotData.push({
                  x: cats, y: cats.map(function (c) { return counts[c]; }), type: 'bar', name: String(h),
                  marker: { color: HUE_COLORS[i % HUE_COLORS.length] }
                });
              });
              layout.barmode = 'stack';
              layout.xaxis.title.text = yCol;
              layout.yaxis.title.text = 'Count';
            } else {
              const counts = {};
              dataX.forEach(function (v) { counts[v] = (counts[v] || 0) + 1; });
              const sorted = Object.keys(counts).map(function (k) { return [k, counts[k]]; }).sort(function (a, b) { return b[1] - a[1]; });
              plotData = [{
                x: sorted.map(function (e) { return e[0]; }), y: sorted.map(function (e) { return e[1]; }), type: 'bar',
                marker: { color: HUE_COLORS[0] }
              }];
              layout.barmode = 'stack';
              layout.xaxis.title.text = xCol || yCol;
              layout.yaxis.title.text = 'Count';
            }
            break;
          }

          default:
            container.innerHTML = '<p class="text-red-500 p-4">Unknown plot type: ' + plotType + '</p>';
            return;
        }

        // Guard: nothing to show
        if (!plotData.length) {
          container.innerHTML =
            '<div class="flex flex-col items-center justify-center h-48 text-gray-400">' +
            '<p class="font-medium">No data to display for this combination.</p>' +
            '<p class="text-sm mt-1">Try a different column or plot type.</p>' +
            '</div>';
          return;
        }

        const config = {
          responsive: true,
          displayModeBar: true,
          displaylogo: false,
          modeBarButtonsToRemove: ['lasso2d', 'select2d'],
          toImageButtonOptions: { format: 'png', filename: plotType, height: 540, width: 960, scale: 2 }
        };

        container.innerHTML = '';
        Plotly.newPlot(container, plotData, layout, config).then(function () {
          container.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        });

      } catch (err) {
        console.error('Plot generation error:', err);
        container.innerHTML =
          '<div class="bg-red-50 border border-red-200 rounded-xl p-6 text-red-700">' +
          '<p class="font-semibold">Failed to generate plot</p>' +
          '<p class="text-sm mt-1">' + err.message + '</p>' +
          '<p class="text-xs mt-2 text-red-400">Make sure the backend server is running on port 8000.</p>' +
          '</div>';
      }
    }

    // Build a readable plot title from the selected options
    function buildPlotTitle(plotType, xCol, yCol, hueCol) {
      const label = plotType.replace(/_/g, ' ').replace(/\b\w/g, function (l) { return l.toUpperCase(); });
      const axes = [xCol, yCol].filter(Boolean);
      let title = label;
      if (axes.length) { title += ' - ' + axes.join(' vs '); }
      if (hueCol) { title += ' (by ' + hueCol + ')'; }
      return title;
    }
  </script>
  <script src="header.js"></script>
</body>

</html>